import { promises as fs } from "node:fs";
import { join, parse } from "node:path";
import { compile } from "json-schema-to-typescript";
import pc from "picocolors";

async function findJsonFiles(dir: string): Promise<string[]> {
  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files: string[] = [];
    for (const entry of entries) {
      const fullPath = join(dir, entry.name);
      if (entry.isDirectory()) {
        files.push(...(await findJsonFiles(fullPath)));
      } else if (entry.isFile() && entry.name.endsWith(".json")) {
        files.push(fullPath);
      }
    }
    return files;
  } catch (err: any) {
    if (err.code === "ENOENT") {
      console.error(pc.red(`Error: Schema directory '${dir}' does not exist.`));
      process.exit(1);
    }
    throw err;
  }
}

export async function generateCommand(options: {
  schemas?: string;
  out?: string;
  protocol?: string;
}) {
  console.log(pc.cyan(`\n⚡ ocpp-ws-cli: Generating from JSON Schemas\n`));

  if (!options.schemas || !options.out) {
    console.error(pc.red("Error: --schemas and --out arguments are required."));
    console.log(
      pc.gray(
        "Example: ocpp generate --schemas ./schemas --out ./src/generated",
      ),
    );
    process.exit(1);
  }

  const { schemas, out } = options;

  console.log(pc.gray(`Reading validation schemas from: ${schemas}`));
  console.log(pc.gray(`Outputting TypeScript typings to: ${out}\n`));

  try {
    // Ensure output directory exists
    await fs.mkdir(out, { recursive: true });

    // Recursively find all JSON schemas
    const schemaFiles = await findJsonFiles(schemas);

    if (schemaFiles.length === 0) {
      console.warn(pc.yellow(`No .json files found in ${schemas}`));
      return;
    }

    let successCount = 0;

    const methodsMap = new Map<
      string,
      { req?: string; conf?: string; reqFile?: string; confFile?: string }
    >();

    const toPascalCase = (str: string) =>
      str
        .replace(/^urn:/, "")
        .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())
        .replace(/^[a-z]/, (chr) => chr.toUpperCase());

    for (const file of schemaFiles) {
      const { name } = parse(file);
      console.log(pc.blue(`Compiling ${name}.json...`));

      try {
        const fileContent = await fs.readFile(file, "utf-8");
        const json = JSON.parse(fileContent);

        let tsCode =
          "/* eslint-disable */\n/**\n * This file was automatically generated by ocpp-ws-cli.\n * DO NOT MODIFY IT BY HAND.\n */\n\n";

        const compileOpts = {
          bannerComment: "",
          style: { singleQuote: false },
        };

        const processSchema = async (schema: any) => {
          const rawId = schema.$id || name;
          const interfaceName = toPascalCase(rawId);

          if (options.protocol) {
            const baseMethod = rawId
              .replace(/^urn:/, "")
              .replace(/\.(req|conf|request|response)$/i, "");
            const isReq = /\.(req|request)$/i.test(rawId);
            const isConf = /\.(conf|response)$/i.test(rawId);

            if (!methodsMap.has(baseMethod)) methodsMap.set(baseMethod, {});
            const entry = methodsMap.get(baseMethod)!;

            if (isReq) {
              entry.req = interfaceName;
              entry.reqFile = name;
            } else if (isConf) {
              entry.conf = interfaceName;
              entry.confFile = name;
            } else {
              // If we can't infer req/conf, we just ignore for the map or default to req.
            }
          }

          // Let compile use our exact pascal cased name so it matches what we import.
          schema.title = interfaceName;

          return await compile(schema, interfaceName, compileOpts);
        };

        if (Array.isArray(json)) {
          for (const schema of json) {
            tsCode += `${await processSchema(schema)}\n`;
          }
        } else {
          tsCode += await processSchema(json);
        }

        const outFile = join(out, `${name}.ts`);
        await fs.writeFile(outFile, tsCode, "utf-8");

        console.log(pc.green(`  ✔ Generated ${outFile}`));
        successCount++;
      } catch (compileError: any) {
        console.error(
          pc.red(`  ✖ Failed to compile ${name}.json: ${compileError.message}`),
        );
      }
    }

    console.log(
      pc.cyan(
        `\n✨ Successfully generated ${successCount} TypeScript declaration files!`,
      ),
    );
    if (options.protocol && methodsMap.size > 0) {
      let indexCode = `/* eslint-disable */\n// @ts-nocheck\n\n`;
      const imports = new Map<string, Set<string>>();

      for (const data of methodsMap.values()) {
        if (data.req && data.reqFile) {
          if (!imports.has(data.reqFile)) imports.set(data.reqFile, new Set());
          imports.get(data.reqFile)!.add(data.req);
        }
        if (data.conf && data.confFile) {
          if (!imports.has(data.confFile))
            imports.set(data.confFile, new Set());
          imports.get(data.confFile)!.add(data.conf);
        }
      }

      for (const [file, types] of imports.entries()) {
        indexCode += `import type { ${Array.from(types).join(
          ", ",
        )} } from "./${file}.js";\n`;
      }

      const protocolInterfaceName = `${toPascalCase(options.protocol)}Methods`;
      indexCode += `\nexport interface ${protocolInterfaceName} {\n`;
      for (const [method, data] of methodsMap.entries()) {
        indexCode += `  "${method}": {\n`;
        indexCode += `    request: ${data.req ? data.req : "unknown"};\n`;
        indexCode += `    response: ${data.conf ? data.conf : "unknown"};\n`;
        indexCode += `  };\n`;
      }
      indexCode += `}\n\n`;

      indexCode += `declare module "ocpp-ws-io" {\n`;
      indexCode += `  interface OCPPMethodMap {\n`;
      indexCode += `    "${options.protocol}": ${protocolInterfaceName};\n`;
      indexCode += `  }\n`;
      indexCode += `}\n`;

      await fs.writeFile(join(out, "index.ts"), indexCode, "utf-8");
      console.log(
        pc.green(
          `\n  ✔ Generated augmented index.ts for protocol '${options.protocol}'`,
        ),
      );
    }
  } catch (error: any) {
    console.error(pc.red(`\nGeneration failed: ${error.message}`));
    process.exit(1);
  }
}
