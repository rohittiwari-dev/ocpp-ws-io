import fs from "node:fs";
import path from "node:path";
import * as p from "@clack/prompts";
import pc from "picocolors";
import { fetchSchema } from "../lib/schema-fetcher.js";
import {
  extractMethods,
  generateVersionFile,
  type SchemaEntry,
  type VersionConfig,
} from "../lib/type-generator.js";

const EXAMPLE_SCHEMA_URL =
  "https://ocpp-ws-io.rohittiwari.me/schema-example.json";

interface GenerateOptions {
  out?: string;
  schema?: string;
  name?: string;
}

export async function runGenerate(options: GenerateOptions): Promise<void> {
  p.intro(pc.bgCyan(pc.black(" ⚡ OCPP Type Generator ")));

  // ── Schema source ───────────────────────────────────────────

  let schemaSource: string;

  if (options.schema) {
    schemaSource = options.schema;
  } else {
    const result = await p.text({
      message:
        "Enter a schema URL or local file path to generate types from.\n" +
        pc.dim(
          "  This should be a JSON array of OCPP-style schema entries with $id fields.\n" +
            `  Example: ${pc.underline(EXAMPLE_SCHEMA_URL)}`,
        ),
      initialValue: EXAMPLE_SCHEMA_URL,
      validate: (val) => {
        if (!val?.trim()) return "Schema source is required";
      },
    });

    if (p.isCancel(result)) {
      p.cancel("Cancelled.");
      return;
    }

    schemaSource = result as string;
  }

  // ── Subprotocol name ────────────────────────────────────────

  let subprotocol: string;

  if (options.name) {
    subprotocol = options.name;
  } else {
    const result = await p.text({
      message:
        "What subprotocol name should these types be registered under?\n" +
        pc.dim(
          "  This maps to the protocol string in OCPPClient<P> / server.handle(protocol, ...).\n" +
            '  Examples: "ocpp1.6", "ocpp2.0.1", "my-custom-protocol"',
        ),
      initialValue: "my-custom-protocol",
      validate: (val) => {
        if (!val?.trim()) return "Subprotocol name is required";
      },
    });

    if (p.isCancel(result)) {
      p.cancel("Cancelled.");
      return;
    }

    subprotocol = result as string;
  }

  // ── Output directory ────────────────────────────────────────

  let outDir: string;

  if (options.out) {
    outDir = path.resolve(options.out);
  } else {
    const result = await p.text({
      message: "Where should the types be generated?",
      initialValue: "./@types/ocpp-ws-io",
      validate: (val) => {
        if (!val?.trim()) return "Directory path is required";
      },
    });

    if (p.isCancel(result)) {
      p.cancel("Cancelled.");
      return;
    }

    outDir = path.resolve(result as string);
  }

  // ── Fetch & Generate ────────────────────────────────────────

  const spinner = p.spinner();

  spinner.start(
    `Fetching schema from ${pc.cyan(
      schemaSource.length > 60 ? `...${schemaSource.slice(-57)}` : schemaSource,
    )}`,
  );

  let schema: SchemaEntry[];
  try {
    schema = await fetchSchema(schemaSource);
  } catch (err) {
    spinner.stop(`${pc.red("✗")} Failed to fetch schema`);
    p.log.error((err as Error).message);
    p.outro(pc.red("Generation failed."));
    process.exit(1);
  }

  spinner.stop(`${pc.green("✓")} Schema loaded — ${schema.length} entries`);

  // ── Generate types ──────────────────────────────────────────

  spinner.start(`Generating ${pc.cyan(subprotocol)} types...`);

  const safeName = subprotocol
    .replace(/[^a-zA-Z0-9]/g, "_")
    .replace(/^_+|_+$/g, "")
    .replace(/_([a-z])/g, (_, c) => c.toUpperCase());

  const mapName = `${
    safeName.charAt(0).toUpperCase() + safeName.slice(1)
  }Methods`;
  const fileKey = safeName.toLowerCase();

  const version: VersionConfig = {
    key: fileKey,
    file: path.basename(schemaSource),
    mapName,
    protocol: subprotocol,
  };

  const methods = extractMethods(schema);

  if (methods.size === 0) {
    spinner.stop(`${pc.yellow("⚠")} No methods found in schema`);
    p.log.warn(
      "The schema must contain entries with $id fields matching:\n" +
        pc.dim("  urn:MethodName.req / urn:MethodName.conf\n") +
        pc.dim("  urn:MethodNameRequest / urn:MethodNameResponse"),
    );
    p.outro(pc.red("No types generated."));
    process.exit(1);
  }

  const code = generateVersionFile(version, methods);

  fs.mkdirSync(outDir, { recursive: true });
  const outFile = `${fileKey}.ts`;
  fs.writeFileSync(path.join(outDir, outFile), code);

  spinner.stop(
    `${pc.green("✓")} ${pc.bold(subprotocol)} — ${
      methods.size
    } methods → ${pc.dim(outFile)}`,
  );

  // ── Augmentation file ───────────────────────────────────────

  const augmentCode = [
    `// Auto-generated by ocpp-ws-cli — DO NOT EDIT`,
    `/* eslint-disable */`,
    ``,
    `import type { ${mapName} } from "./${fileKey}.js";`,
    ``,
    `declare module "ocpp-ws-io" {`,
    `  interface OCPPMethodMap {`,
    `    "${subprotocol}": ${mapName};`,
    `  }`,
    `}`,
    ``,
  ].join("\n");

  fs.writeFileSync(path.join(outDir, "augment.d.ts"), augmentCode);
  p.log.success(
    `${pc.green("✓")} ${pc.bold(
      "augment.d.ts",
    )} — module augmentation for "${subprotocol}"`,
  );

  // ── Summary ─────────────────────────────────────────────────

  const methodNames = [...methods.keys()].slice(0, 5);
  const moreCount = methods.size - methodNames.length;

  p.note(
    [
      `${pc.bold("Output:")}      ${pc.dim(outDir)}`,
      `${pc.bold("Protocol:")}    ${subprotocol}`,
      `${pc.bold("Methods:")}     ${methods.size} total`,
      `${pc.bold("Files:")}       ${outFile}, augment.d.ts`,
      "",
      pc.dim("Methods: ") +
        methodNames.map((m) => pc.cyan(m)).join(", ") +
        (moreCount > 0 ? pc.dim(` +${moreCount} more`) : ""),
      "",
      pc.dim("Add to tsconfig.json:"),
      "",
      pc.cyan(`  "include": ["${path.relative(process.cwd(), outDir)}/**/*"]`),
    ].join("\n"),
    "✨ Generation Complete",
  );

  p.outro(
    `${pc.green("Done!")} Types ready at ${pc.underline(
      path.relative(process.cwd(), outDir),
    )}`,
  );
}
