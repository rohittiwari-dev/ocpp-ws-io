---
title: Comparison
description: "How ocpp-ws-io approaches common OCPP challenges differently from other Node.js libraries."
---

import { Callout } from "fumadocs-ui/components/callout";

# Comparison with Alternatives

Building a scalable OCPP Central System or Station client involves navigating multiple architectural trade-offs: memory management, connection tracking, horizontal clustering, and protocol compliance.

`ocpp-ws-io` isn't the only option. Here's how it differs from other popular Node.js OCPP libraries.

<Callout type="warn">
  **A note on honesty**: `ocpp-ws-io` is a newer library with a smaller user
  base compared to the alternatives listed below. It has been tested primarily
  in controlled environments and small-scale deployments — not yet at the scale
  of libraries with years of community adoption. We've built it to scratch our
  own itch: solving specific architectural gaps (clustering, routing,
  observability) that we repeatedly ran into. OCPP 2.1 types are auto-generated
  from the [official OCA
  schemas](https://openchargealliance.org/protocols/open-charge-point-protocol/#OCPP2.1)
  and are type-safe, but have not been tested against real OCPP 2.1 hardware.
  The comparisons below are based on our reading of each library's public source
  code and documentation. If anything is inaccurate, [please open an
  issue](https://github.com/rohittiwari-dev/ocpp-ts-rpc/issues).
</Callout>

---

## 1. `@voltbras/ts-ocpp`

`@voltbras/ts-ocpp` is a popular, strongly typed, TypeScript-first OCPP library.

**Where they excel:**

- Excellent out-of-the-box TypeScript types.
- Simple class-based OOP API design.
- Larger community and more mature adoption.

**What `ocpp-ws-io` addresses differently:**

- **Clustering**: `ts-ocpp` stores connections in memory class instances. When scaling across multiple pods or load balancer nodes, you need to build your own message brokering. `ocpp-ws-io` provides a `RedisAdapter` (Stream + Pub/Sub) for unicast routing across nodes.
- **Rate Limiting**: `ocpp-ws-io` includes socket-level token bucket rate limiters that can drop high-frequency messages (e.g., `MeterValues`) before parsing, while allowing critical messages through.
- **Path-based Routing**: `ts-ocpp` uses class-based handlers. `ocpp-ws-io` offers Express-style path routing (`OCPPRouter`) with scoped middleware and authentication per route.

---

## 2. `ocpp-eliftech`

`ocpp-eliftech` is one of the oldest JavaScript/Node packages for OCPP implementation.

**Where they excel:**

- Long track record — it has been used in production for years.
- Complete implementation of OCPP 1.6-J.
- Minimal and unopinionated design.

**What `ocpp-ws-io` addresses differently:**

- **Modern TypeScript**: `ocpp-eliftech` relies on older Promise patterns and prototypical inheritance. `ocpp-ws-io` uses TypeScript async/await and provides auto-generated types for all OCPP methods.
- **Schema Validation**: `ocpp-ws-io` implements runtime JSON schema validation using AJV, mapping violations to OCPP-J error codes (e.g., `FormatViolation` vs `PropertyConstraintViolation`).
- **Idempotency Keys**: To prevent duplicate processing on network retries, `ocpp-ws-io` supports deterministic message IDs (`idempotencyKey`) on `call()`.
- **Observability**: `ocpp-ws-io` provides built-in Prometheus metrics (`/metrics`) and health endpoints (`/health`).

---

## 3. `rpc-websockets`

While not an OCPP library, many teams pipe raw WebSocket JSON-RPC through `rpc-websockets` and build OCPP logic on top.

**Where they excel:**

- Lightweight and protocol-agnostic JSON-RPC execution.
- No OCPP-specific constraints imposed on the developer.

**What `ocpp-ws-io` addresses differently:**

- **OCPP Awareness**: `rpc-websockets` doesn't understand `CallError` (Type [4]) or how OCPP error payloads differ from generic JSON-RPC. With `ocpp-ws-io`, OCPP-J framing (Call, CallResult, CallError) is handled natively.
- **Subprotocol Negotiation**: `ocpp-ws-io` manages `ocpp1.6` vs `ocpp2.0.1` subprotocol negotiation at the HTTP upgrade layer and routes calls into version-typed handlers.
- **Spec Compliance**: Generic RPC libraries allow fire-and-forget (`noReply: true`). OCPP requires every message to be correlated and tracked. `ocpp-ws-io` enforces this while providing `NOREPLY` as an explicit opt-out.

---

## 4. `ocpp-rpc`

`ocpp-rpc` is another widely used OCPP JSON-RPC library for Node.js.

**Where they excel:**

- Strict validation matching the official OCPP JSON schemas.
- Clean separation between CSMS and Charge Point roles.

**What `ocpp-ws-io` addresses differently:**

- **WebSocket Routing**: Both libraries use the `ws` library directly. `ocpp-ws-io` adds Express-style path routing (`OCPPRouter`) at the WebSocket layer — scoped middleware, authentication, and path matchers (e.g., `/api/v2/chargers/*`) without requiring an external HTTP framework.
- **Clustering**: `ocpp-rpc` leaves multi-node pub/sub bridging to you. `ocpp-ws-io` provides a `RedisAdapter` for presence tracking and stream-based unicast routing across nodes.

---

## 5. Scalability Approach

When scaling horizontally, the architecture of your WebSocket library matters. Here is how `ocpp-ws-io` approaches common scaling concerns.

### Horizontal Scalability

| Concern                              | Typical In-Memory Libraries    | `ocpp-ws-io` (with RedisAdapter)                         |
| :----------------------------------- | :----------------------------- | :------------------------------------------------------- |
| **Multi-Node Routing**               | Manual implementation required | Presence registry with O(1) lookup                       |
| **Connection Rehydration**           | Connections lost on restart    | Automatic Redis presence re-registration on reconnect    |
| **Surge Handling (Thundering Herd)** | No built-in protection         | Randomized ±25% ping jitter + token bucket rate limiters |

### Throughput Design

- **Selective validation bypass**: High-frequency messages like `Heartbeat` can skip JSON schema validation via `strictModeMethods`, reducing CPU overhead for trusted traffic.
- **Redis pipeline batching**: `broadcastBatch()` groups unicast commands per target node and dispatches them in a single `Redis.pipeline()` call, collapsing N individual round-trips into one per node.

### Resource Management

- **Session TTLs**: Dead connections are evicted after a configurable `sessionTtlMs` rather than being immediately dropped, preserving state across temporary disconnects.
- **Socket-level rate limiting**: Token bucket rate limiters operate at the transport layer, dropping traffic before payload parsing.
- **Built-in observability**: `healthEndpoint: true` exposes `/health` and Prometheus `/metrics` on the native HTTP server.

---

## When to Use What

| Your Situation                                              | Recommended Library                    |
| :---------------------------------------------------------- | :------------------------------------- |
| Simple single-instance OCPP 1.6 app, mature community       | `@voltbras/ts-ocpp` or `ocpp-eliftech` |
| Bare-metal JSON-RPC, you want full control                  | `rpc-websockets`                       |
| Strict OCPP validation, clean CSMS/CP separation            | `ocpp-rpc`                             |
| Need clustering, path routing, rate limiting, observability | `ocpp-ws-io`                           |

`ocpp-ws-io` is an open-source tool built to solve specific infrastructure problems. If those problems aren't yours, the other libraries listed here are excellent choices.
