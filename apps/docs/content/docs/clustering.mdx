---
title: Clustering (Redis)
description: Scale your OCPP server with Redis Streams and Pub/Sub.
---

# Clustering

`ocpp-ws-io` includes a powerful Redis adapter that allows you to scale your WebSocket server across multiple nodes (e.g., in Kubernetes or behind a load balancer).

## Architecture

The adapter uses a hybrid approach for maximum performance and reliability:

1.  **Broadcast (Pub/Sub)**: For messages that must reach _all_ nodes (e.g., broad system events).
2.  **Unicast (Streams)**: For point-to-point routing (e.g., sending a command to a specific Charge Point). This uses Redis Streams to ensure **zero message loss** if a node temporarily restarts.
3.  **Presence**: Automatically tracks which node a Charge Point is connected to.

## Installation

```bash
npm install ioredis
```

## Configuration

You should provide three Redis connections for optimal performance:

1.  **Publisher**: Sends commands and events.
2.  **Subscriber**: Listens for broadcasts.
3.  **Blocking**: Dedicted connection for `XREAD` (blocking stream reads).

### Usage with `ioredis`

```typescript
import { OCPPServer } from "ocpp-ws-io";
import { RedisAdapter } from "ocpp-ws-io/adapters/redis";
import Redis from "ioredis";

const server = new OCPPServer({ protocols: ["ocpp1.6", "ocpp2.0.1"] });

// Create isolated connections
const pub = new Redis(process.env.REDIS_URL);
const sub = new Redis(process.env.REDIS_URL);
const blocking = new Redis(process.env.REDIS_URL);

server.setAdapter(
  new RedisAdapter({
    pubClient: pub,
    subClient: sub,
    blockingClient: blocking, // Recommended for Streams
    prefix: "ocpp-cluster:", // Optional
    streamMaxLen: 1000, // Keep last 1000 messages per node
  }),
);

await server.listen(3000);
```

## Features

### Unicast Routing (`safeSendToClient`)

When you use `server.safeSendToClient()`, the adapter:

1.  Checks the **Presence Registry** to find which node holds the connection.
2.  Publishes the message to that specific node's **Redis Stream**.
3.  The target node consumes the stream and sends the WebSocket message.

```typescript
// Works from ANY node in the cluster
await server.safeSendToClient("CP001", "ocpp1.6", "Reset", { type: "Hard" });
```

### Reliability

Unlike standard Pub/Sub, **Redis Streams persist messages**. If a node crashes and restarts with the same ID, it will resume processing its stream, ensuring no pending commands are lost.

### Configuration Options

| Option           | Type     | Description                           |
| :--------------- | :------- | :------------------------------------ |
| `pubClient`      | `Redis`  | Used for publishing and setting keys. |
| `subClient`      | `Redis`  | Used for Pub/Sub subscriptions.       |
| `blockingClient` | `Redis`  | (Optional) Dedicated for `XREAD`.     |
| `prefix`         | `string` | Key prefix (default: `ocpp-ws-io:`).  |
| `streamMaxLen`   | `number` | Max stream length (default: `1000`).  |

## Custom Adapters (EventAdapterInterface)

If you don't use Redis, you can implement your own clustering mechanism (e.g., using RabbitMQ, NATS, or Kafka) by conforming to the `EventAdapterInterface`. An adapter must implement four basic responsibilities:

```typescript
import { EventAdapterInterface, OCPPMessage } from "ocpp-ws-io";

export class MyCustomAdapter implements EventAdapterInterface {
  /**
   * 1. Bind to the local server instance
   * Called automatically by `server.setAdapter(adapter)`
   */
  public bind(server: OCPPServer): void {
    // Store the server reference and subscribe to external messaging topics
  }

  /**
   * 2. Broadcast a global event
   * Tell the adapter to broadcast an event (like a disconnect) to ALL nodes.
   */
  public publishEvent(event: string, payload: unknown): void {
    // e.g. nats.publish("ocpp-global", JSON.stringify({ event, payload }))
  }

  /**
   * 3. Track Presence
   * Record that a charging station is currently governed by THIS node.
   */
  public async registerClient(identity: string): Promise<void> {
    // e.g. cache.set(`presence:${identity}`, server.nodeId)
  }

  /**
   * 4. Point-to-Point Messaging
   * Send a raw OCPP WebSocket message to a specific station on the cluster.
   */
  public async sendToClient(
    identity: string,
    message: OCPPMessage,
  ): Promise<void> {
    // 1. Find which node ID owns `identity`
    // 2. Publish `message` to that node's specific queue
    // 3. The receiving node will call `server.getLocalClient(identity)?.sendRaw(...)`
  }
}
```

Once implemented, simply use your adapter: `server.setAdapter(new MyCustomAdapter())`.
