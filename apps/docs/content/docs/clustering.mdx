---
title: Clustering (Redis)
description: Scaling your OCPP server with Redis.
---

For multi-instance deployments (e.g., Kubernetes, load balancers), you need to synchronize state and events across server instances. `ocpp-ws-io` provides a `RedisAdapter` for this purpose.

## Installation

You need to allow `ocpp-ws-io` to access your Redis client. The adapter is compatible with `ioredis` and `node-redis`.

## Usage

```typescript
import { OCPPServer } from "ocpp-ws-io";
import { RedisAdapter } from "ocpp-ws-io/adapters/redis";
import Redis from "ioredis";

const server = new OCPPServer({ protocols: ["ocpp2.0.1"] });

// Create two clients: one for publishing, one for subscribing
const pub = new Redis();
const sub = new Redis();

server.setAdapter(
  new RedisAdapter({
    pubClient: pub,
    subClient: sub,
    prefix: "ocpp:", // optional, default: 'ocpp-ws-io:'
  }),
);

server.on("client", (client) => {
  console.log(`${client.identity} connected`);
});

await server.listen(3000);
```

## How it works

When you use the `RedisAdapter`, the following happens:

1.  **Broadcasts**: If you call `server.broadcast()`, the message is published to Redis and sent by _all_ server instances to their connected clients.
2.  **Loop Prevention**: The sender node's ID is attached to the message, ensuring it doesn't re-broadcast to itself.
3.  **State Sync**: (If implemented features require it) Shared state usage leverages Redis.

_Note: Pure point-to-point calls (`client.call`) still route directly to the connected socket. The clusters are primarily for broadcast and discovery scenarios._
